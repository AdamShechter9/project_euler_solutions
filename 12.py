"""
Project Euler
Problem 12

The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

SOLUTION:
This is a two part problem.  First part is calculating the triangle numbers.
The second part is counting the factors.
Using a generator for the triangle numbers seems logical.
Counting the factors will be done using a for loop.

I ended up using multithreading, since single thread calculation seemed slow.

author:  Adam Shechter
"""
import queue
import threading


def main():
    work_queue = queue.Queue()
    result_queue = queue.Queue()
    start_daemons(30, work_queue, result_queue)
    print(find_factors_tri_nums_seq(500, work_queue, result_queue))


def start_daemons(num_workers, work_queue, result_queue):
    for i in range(num_workers):
        worker = threading.Thread(
            target=_perform_action_worker,
            args=(work_queue, result_queue),
            name='worker-{}'.format(i)
        )
        worker.setDaemon(True)
        worker.start()


def _perform_action_worker(work_queue, result_queue):
    while 1:
        work_request = work_queue.get()
        curr_fac = find_factors(work_request)
        result_queue.put(curr_fac)
        work_queue.task_done()


def find_factors_tri_nums_seq(fac_n, work_queue, result_queue):
    tri_nums = tri_nums_seq_gen()
    while 1:
        curr_num = next(tri_nums)
        work_queue.put(curr_num)
        curr_fac = result_queue.get()
        print("{}:   factors # {}".format(curr_num, len(curr_fac)))
        if len(curr_fac) >= fac_n:
            return curr_num


def find_factors(n):
    factors = []
    i = 1
    while i <= (n//2+1):
        if n % i == 0:
            if i not in factors:
                factors.append(i)
            if (n//i) not in factors:
                factors.append((n//i))
        i += 1
    return factors


def tri_nums_seq_gen():
    i = 1
    tri_sum = 0
    while 1:
        tri_sum += i
        yield tri_sum
        i += 1


if __name__ == '__main__':
    main()
